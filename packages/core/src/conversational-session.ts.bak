import { EventEmitter } from 'eventemitter3';
import type { BmadClient } from './client.js';
import type {
  ConversationalOptions,
  ConversationTurn,
  ConversationResult,
  ConversationalStatus,
  Message,
  AgentDefinition,
  CostReport,
  Document,
  ModelCost,
  ToolCall,
  LLMProvider,
} from './types.js';
import { SystemPromptGenerator } from './prompt-generator.js';
import { AgentLoader } from './agent-loader.js';
import { AnthropicProvider } from './providers/anthropic.js';
import { FallbackToolExecutor } from './tools/fallback-executor.js';

/**
 * ConversationalSession - Multi-turn conversational interaction with an agent
 *
 * Unlike BmadSession (one-shot execution), ConversationalSession allows sending
 * multiple messages to the same agent, maintaining context across turns.
 * This provides a Claude Code-like REPL experience.
 */
export class ConversationalSession extends EventEmitter {
  readonly id: string;
  readonly agentId: string;

  private client: BmadClient;
  private options: ConversationalOptions;
  private status: ConversationalStatus = 'idle';
  private startTime?: number;
  private endTime?: number;

  // Components
  private promptGenerator: SystemPromptGenerator;
  private agentLoader: AgentLoader;
  private provider?: LLMProvider;
  private toolExecutor: FallbackToolExecutor;

  // Persistent state across turns
  private messages: Message[] = []; // Cumulative conversation history
  private turns: ConversationTurn[] = [];
  private totalInputTokens = 0;
  private totalOutputTokens = 0;
  private apiCallCount = 0;
  private perModelUsage = new Map<string, { inputTokens: number; outputTokens: number }>();

  // Current turn state
  private currentTurnStartTime?: number;
  private currentTurnUserMessage?: string;
  private currentTurnToolCalls: ToolCall[] = [];
  private currentTurnInputTokens = 0;
  private currentTurnOutputTokens = 0;

  // Question handling
  private pendingQuestion?: {
    question: string;
    context?: string;
    resolve: (answer: string) => void;
    reject: (error: Error) => void;
  };

  // Agent definition (loaded once)
  private agent?: AgentDefinition;

  constructor(
    client: BmadClient,
    agentId: string,
    options?: ConversationalOptions,
    testProvider?: LLMProvider // For testing only
  ) {
    super();
    this.client = client;
    this.agentId = agentId;
    this.options = options || {};
    this.id = this.generateConversationId();

    // Initialize components
    this.promptGenerator = new SystemPromptGenerator();
    this.agentLoader = new AgentLoader(client.getLogger());
    this.toolExecutor = new FallbackToolExecutor();

    // Use test provider if provided (for testing)
    if (testProvider) {
      this.provider = testProvider;
    }

    // Initialize VFS if context has initial files
    if (this.options.context?.['initialFiles']) {
      this.toolExecutor.initializeFiles(this.options.context['initialFiles'] as Record<string, string>);
    }

    this.client.getLogger().debug('Conversational session created', {
      conversationId: this.id,
      agentId,
    });
  }

  private generateConversationId(): string {
    return `conv_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
  }

  private generateTurnId(): string {
    return `turn_${Date.now()}_${Math.random().toString(36).substring(2, 11)}`;
  }

  /**
   * Initialize the conversation (load agent, setup system prompt)
   */
  private async initialize(): Promise<void> {
    console.log('[initialize] START');
    if (this.agent) {
      console.log('[initialize] Already initialized, returning');
      return; // Already initialized
    }

    this.startTime = Date.now();

    // 1. Load agent definition
    console.log('[initialize] Loading agent...');
    this.agent = await this.loadAgent();
    console.log('[initialize] Agent loaded:', this.agent.agent.id);
    this.client.getLogger().debug('Agent loaded for conversation', { agentId: this.agentId });

    // 2. Load templates and agent files into VFS
    console.log('[initialize] Loading templates into VFS...');
    await this.loadTemplatesIntoVFS(this.agent);
    console.log('[initialize] Templates loaded');

    // 3. Initialize provider (skip if test provider was injected)
    if (!this.provider) {
      console.log('[initialize] Creating provider...');
      const config = this.client.getConfig();
      this.provider = new AnthropicProvider(
        config.provider.apiKey,
        config.provider.model || 'claude-sonnet-4-20250514'
      );
      console.log('[initialize] Provider created');
    } else {
      console.log('[initialize] Using injected provider');
    }

    // 4. Generate system prompt
    console.log('[initialize] Generating system prompt...');
    const tools = this.toolExecutor.getTools();
    const systemPrompt = this.promptGenerator.generate(this.agent, tools);
    console.log('[initialize] System prompt generated, length:', systemPrompt.length);

    // 5. Add system message (only once at start)
    this.messages.push({
      role: 'system',
      content: systemPrompt,
    });

    console.log('[initialize] Complete');
    this.client.getLogger().info('Conversational session initialized', { conversationId: this.id });
  }

  private async loadAgent(): Promise<AgentDefinition> {
    const { resolve, join } = await import('path');
    const expansionPaths = this.client.getConfig().expansionPackPaths || [];
    const fallbackPaths = [
      './.bmad-core/agents',
      '../bmad-export-author/.bmad-core/agents',
      '../bmad-export-author/.bmad-expert-author/agents',
      '../bmad-export-author/.bmad-competency-assessor/agents',
    ];

    for (const basePath of [...expansionPaths, ...fallbackPaths]) {
      const agentPath = resolve(join(basePath, `${this.agentId}.md`));
      try {
        const agent = await this.agentLoader.loadAgent(agentPath);
        return agent;
      } catch (error) {
        // Try next path
        continue;
      }
    }

    throw new Error(`Agent '${this.agentId}' not found in any configured paths`);
  }

  private async loadTemplatesIntoVFS(agent: AgentDefinition): Promise<void> {
    // Load agent file itself
    const agentContent = `# ${agent.agent.name}\n\nAgent definition loaded into VFS`;

    // Use regular write (tools have async write, not sync)
    await this.toolExecutor.execute({
      id: 'init-agent',
      name: 'write_file',
      input: {
        file_path: `/.bmad-core/agents/${this.agentId}.md`,
        content: agentContent,
      },
    });

    // TODO: Load templates and tasks referenced in agent.dependencies
    // For now, we keep VFS minimal
  }

  /**
   * Send a user message (non-blocking)
   * Returns immediately, conversation processes in background
   */
  async send(message: string): Promise<void> {
    console.log('[send] START', { message, status: this.status, hasAgent: !!this.agent });
    if (this.status === 'ended') {
      throw new Error('Cannot send message to ended conversation');
    }

    if (this.status === 'processing') {
      throw new Error('Cannot send message while agent is still processing previous message');
    }

    if (!this.agent) {
      console.log('[send] Initializing...');
      await this.initialize();
      console.log('[send] Initialization complete');
    }

    this.client.getLogger().info('User message received', {
      conversationId: this.id,
      message: message.substring(0, 100),
    });

    console.log('[send] Starting processTurn...');
    // Start processing this turn (non-blocking)
    this.processTurn(message).catch((error) => {
      console.error('[send] processTurn error:', error);
      this.client.getLogger().error('Turn processing failed', { error });
      this.status = 'error';
      this.emit('error', error);
    });
    console.log('[send] processTurn started (non-blocking)');
  }

  /**
   * Process a single turn (internal)
   */
  private async processTurn(userMessage: string): Promise<void> {
    console.log('[processTurn] START', { userMessage });
    this.status = 'processing';
    this.currentTurnStartTime = Date.now();
    this.currentTurnUserMessage = userMessage;
    this.currentTurnToolCalls = [];
    this.currentTurnInputTokens = 0;
    this.currentTurnOutputTokens = 0;

    this.emit('turn-started');

    try {
      // Add user message to conversation
      this.messages.push({
        role: 'user',
        content: userMessage,
      });

      // Tool call loop (like BmadSession.execute)
      let agentResponse = '';
      let continueLoop = true;
      let loopCount = 0;

      while (continueLoop) {
        loopCount++;
        console.log('[processTurn] Loop iteration', loopCount);

        // Check cost limit
        this.checkCostLimit();

        // Send messages to LLM
        console.log('[processTurn] Calling provider.sendMessage...');
        const response = await this.provider!.sendMessage(
          this.messages,
          this.toolExecutor.getTools()
        );
        console.log('[processTurn] Provider response:', { stopReason: response.stopReason, hasToolCalls: !!response.message.toolCalls });

        // Track usage
        this.trackUsage(response.usage);

        // Extract text content
        const textContent = this.extractTextContent(response.message.content);
        if (textContent) {
          agentResponse += textContent + '\n';
        }

        // Handle different stop reasons
        if (response.stopReason === 'tool_use' && response.message.toolCalls) {
          console.log('[processTurn] Handling tool_use, executing', response.message.toolCalls.length, 'tools');
          // Execute tools
          this.currentTurnToolCalls.push(...response.message.toolCalls);

          // Add assistant message with tool calls
          this.messages.push({
            role: 'assistant',
            content: response.message.content,
          });

          // Execute tools and add results
          const toolResults = await this.executeTools(response.message.toolCalls);

          this.messages.push({
            role: 'user',
            content: toolResults,
          });

          // Continue loop
          continueLoop = true;
          console.log('[processTurn] Tool execution complete, continuing loop');
        } else if (response.stopReason === 'end_turn') {
          console.log('[processTurn] Handling end_turn');
          // Turn complete
          this.messages.push({
            role: 'assistant',
            content: response.message.content,
          });

          continueLoop = false;
        } else {
          console.log('[processTurn] Handling other stop reason:', response.stopReason);
          // Other stop reasons (max_tokens, stop_sequence)
          this.messages.push({
            role: 'assistant',
            content: response.message.content,
          });

          continueLoop = false;
        }

        // Check if agent asked a question
        if (textContent && this.isQuestion(textContent)) {
          console.log('[processTurn] Question detected, waiting for answer');
          // Pause for answer
          continueLoop = false;
          await this.waitForAnswer(textContent);
          // After answer, continue processing
          continueLoop = true;
          console.log('[processTurn] Answer received, continuing');
        }

        console.log('[processTurn] End of loop iteration, continueLoop=', continueLoop);
      }

      console.log('[processTurn] Exited loop, completing turn');

      // Turn completed successfully
      console.log('[processTurn] Creating turn object...');
      const turn: ConversationTurn = {
        id: this.generateTurnId(),
        userMessage: this.currentTurnUserMessage!,
        agentResponse: agentResponse.trim(),
        toolCalls: this.currentTurnToolCalls,
        tokensUsed: {
          input: this.currentTurnInputTokens,
          output: this.currentTurnOutputTokens,
        },
        cost: this.calculateTurnCost(),
        timestamp: this.currentTurnStartTime!,
      };
      console.log('[processTurn] Turn object created:', turn.id);

      console.log('[processTurn] Pushing turn to history...');
      this.turns.push(turn);
      console.log('[processTurn] Setting status to idle...');
      this.status = 'idle';
      console.log('[processTurn] Emitting turn-completed...');
      this.emit('turn-completed', turn);
      console.log('[processTurn] Emitting idle...');
      this.emit('idle');

      console.log('[processTurn] Logging completion...');
      this.client.getLogger().info('Turn completed', {
        conversationId: this.id,
        turnId: turn.id,
        cost: turn.cost,
      });
      console.log('[processTurn] END - success');
    } catch (error) {
      console.error('[processTurn] EXCEPTION:', error);
      this.client.getLogger().error('Turn failed', { error });
      this.status = 'error';
      throw error;
    }
  }

  private extractTextContent(content: string | any[]): string {
    if (typeof content === 'string') {
      return content;
    }

    if (Array.isArray(content)) {
      return content
        .filter((block: any) => block.type === 'text')
        .map((block: any) => block.text)
        .join('\n');
    }

    return '';
  }

  private async executeTools(toolCalls: ToolCall[]): Promise<any[]> {
    const results = [];

    for (const toolCall of toolCalls) {
      try {
        const result = await this.toolExecutor.execute(toolCall);
        results.push({
          type: 'tool_result',
          tool_use_id: toolCall.id,
          content: result.content,
        });
      } catch (error: any) {
        results.push({
          type: 'tool_result',
          tool_use_id: toolCall.id,
          content: `Error: ${error.message}`,
          is_error: true,
        });
      }
    }

    return results;
  }

  private isQuestion(text: string): boolean {
    // Simple heuristic: ends with '?'
    return text.trim().endsWith('?');
  }

  private async waitForAnswer(question: string): Promise<void> {
    return new Promise((resolve, reject) => {
      this.status = 'waiting_for_answer';
      this.pendingQuestion = {
        question,
        resolve: () => {
          this.pendingQuestion = undefined;
          this.status = 'processing';
          resolve();
        },
        reject,
      };

      this.emit('question', { question });

      // TODO: Implement timeout
    });
  }

  /**
   * Answer a pending question
   */
  async answer(input: string): Promise<void> {
    if (!this.pendingQuestion) {
      throw new Error('No pending question to answer');
    }

    this.client.getLogger().debug('Answer received', { conversationId: this.id });

    // Add answer to messages
    this.messages.push({
      role: 'user',
      content: input,
    });

    // Resolve the promise to continue processing
    this.pendingQuestion.resolve(input);
  }

  /**
   * Check if agent is idle (ready for next message)
   */
  isIdle(): boolean {
    return this.status === 'idle';
  }

  /**
   * Wait for current processing to complete
   */
  async waitForCompletion(timeoutMs?: number): Promise<ConversationTurn> {
    const timeout = timeoutMs || 300000; // 5 minutes default
    console.log('[waitForCompletion] START, current status:', this.status, 'turns:', this.turns.length);

    return new Promise((resolve, reject) => {
      // If already idle, resolve immediately
      if (this.status === 'idle') {
        console.log('[waitForCompletion] Already idle, resolving immediately');
        const lastTurn = this.turns[this.turns.length - 1];
        if (!lastTurn) {
          console.log('[waitForCompletion] ERROR: No turns yet');
          reject(new Error('No turns completed yet'));
          return;
        }
        console.log('[waitForCompletion] Resolving with turn:', lastTurn.id);
        resolve(lastTurn);
        return;
      }

      // Set up timeout
      const timeoutHandle = setTimeout(() => {
        console.log('[waitForCompletion] TIMEOUT');
        cleanup();
        reject(new Error('Timeout waiting for completion'));
      }, timeout);

      // Listen for completion
      const handleTurnCompleted = (turn: ConversationTurn) => {
        console.log('[waitForCompletion] Turn completed event received:', turn.id);
        cleanup();
        resolve(turn);
      };

      const handleError = (error: Error) => {
        console.log('[waitForCompletion] Error event received');
        cleanup();
        reject(error);
      };

      const cleanup = () => {
        clearTimeout(timeoutHandle);
        this.off('turn-completed', handleTurnCompleted);
        this.off('error', handleError);
      };

      console.log('[waitForCompletion] Listening for turn-completed event...');
      this.once('turn-completed', handleTurnCompleted);
      this.once('error', handleError);
    });
  }

  /**
   * Get conversation history
   */
  getHistory(): ConversationTurn[] {
    return [...this.turns];
  }

  /**
   * Get accumulated documents so far
   */
  getDocuments(): Document[] {
    return this.toolExecutor.getDocuments();
  }

  /**
   * Get current costs
   */
  getCosts(): CostReport {
    const breakdown: ModelCost[] = [];
    const modelInfo = this.provider?.getModelInfo();

    for (const [model, usage] of this.perModelUsage.entries()) {
      breakdown.push({
        model,
        inputTokens: usage.inputTokens,
        outputTokens: usage.outputTokens,
        inputCost: (usage.inputTokens / 1000) * (modelInfo?.inputCostPer1k || 0),
        outputCost: (usage.outputTokens / 1000) * (modelInfo?.outputCostPer1k || 0),
      });
    }

    const totalCost = breakdown.reduce((sum, b) => sum + b.inputCost + b.outputCost, 0);

    return {
      totalCost,
      currency: 'USD',
      inputTokens: this.totalInputTokens,
      outputTokens: this.totalOutputTokens,
      apiCalls: this.apiCallCount,
      breakdown,
    };
  }

  /**
   * Explicitly end the conversation
   */
  async end(): Promise<ConversationResult> {
    if (this.status === 'processing') {
      throw new Error('Cannot end conversation while processing');
    }

    this.status = 'ended';
    this.endTime = Date.now();

    const result: ConversationResult = {
      conversationId: this.id,
      turns: this.turns,
      documents: this.toolExecutor.getDocuments(),
      totalCost: this.getCosts().totalCost,
      totalTokens: {
        input: this.totalInputTokens,
        output: this.totalOutputTokens,
      },
      duration: this.endTime! - this.startTime!,
    };

    this.client.getLogger().info('Conversation ended', {
      conversationId: this.id,
      turns: result.turns.length,
      cost: result.totalCost,
    });

    return result;
  }

  private trackUsage(usage: { inputTokens: number; outputTokens: number }): void {
    this.totalInputTokens += usage.inputTokens;
    this.totalOutputTokens += usage.outputTokens;
    this.currentTurnInputTokens += usage.inputTokens;
    this.currentTurnOutputTokens += usage.outputTokens;
    this.apiCallCount++;

    const model = this.provider!.getModelInfo().name;
    const current = this.perModelUsage.get(model) || { inputTokens: 0, outputTokens: 0 };
    this.perModelUsage.set(model, {
      inputTokens: current.inputTokens + usage.inputTokens,
      outputTokens: current.outputTokens + usage.outputTokens,
    });
  }

  private calculateTurnCost(): number {
    return this.provider!.calculateCost({
      inputTokens: this.currentTurnInputTokens,
      outputTokens: this.currentTurnOutputTokens,
    });
  }

  private checkCostLimit(): void {
    if (!this.options.costLimit) {
      return;
    }

    const costs = this.getCosts();
    const currentCost = costs.totalCost;

    if (currentCost > this.options.costLimit) {
      throw new Error(
        `Cost limit exceeded: $${currentCost.toFixed(2)} > $${this.options.costLimit.toFixed(2)}`
      );
    }

    // Emit warning at 80%
    const warningThreshold = this.options.costLimit * 0.8;
    if (currentCost > warningThreshold) {
      this.emit('cost-warning', currentCost);
    }
  }
}
